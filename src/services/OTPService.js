const crypto = require('crypto');

class OTPService {
    constructor(dbManager, telegramClientService = null) {
        this.dbManager = dbManager;
        this.telegramClientService = telegramClientService;
        this.otpStore = new Map(); // phoneNumber -> { otp, expiry, attempts }
        this.maxAttempts = 3;
        this.otpExpiry = 5 * 60 * 1000; // 5 minutes
        
        // Initialize Twilio if credentials are provided
        this.twilioClient = null;
        if (process.env.TWILIO_ACCOUNT_SID && process.env.TWILIO_AUTH_TOKEN) {
            try {
                const twilio = require('twilio');
                this.twilioClient = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);
                console.log('‚úÖ Twilio SMS service initialized');
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to initialize Twilio:', error.message);
            }
        } else {
            console.log('‚ÑπÔ∏è Twilio credentials not provided, SMS will be mocked');
        }
    }

    generateOTP() {
        // Generate 6-digit OTP
        return Math.floor(100000 + Math.random() * 900000).toString();
    }

    async sendOTP(phoneNumber) {
        try {
            console.log(`üì± Generating OTP for ${phoneNumber}`);
            
            // Validate phone number format
            if (!phoneNumber.startsWith('+')) {
                throw new Error('S·ªë ƒëi·ªán tho·∫°i ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng m√£ qu·ªëc gia (vd: +84)');
            }

            // Generate OTP
            const otp = this.generateOTP();
            const expiry = Date.now() + this.otpExpiry;

            // Store OTP
            this.otpStore.set(phoneNumber, {
                otp,
                expiry,
                attempts: 0,
                createdAt: Date.now()
            });

            // Clean expired OTPs
            this.cleanExpiredOTPs();

            console.log(`üîê OTP for ${phoneNumber}: ${otp}`);
            console.log(`‚è∞ Expires in 5 minutes`);

            // Try to send via Telegram first
            let sentViaTelegram = false;
            let telegramError = null;

            try {
                await this.sendViaTelegram(phoneNumber, otp);
                sentViaTelegram = true;
                console.log(`‚úÖ OTP sent via Telegram to ${phoneNumber}`);
            } catch (error) {
                telegramError = error;
                console.log(`‚ö†Ô∏è Telegram send failed: ${error.message}`);
                console.log(`üì® Falling back to SMS for ${phoneNumber}`);
            }

            // Track which method was used
            let deliveryMethod = 'telegram';
            let deliveryMessage = 'M√£ OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i qua Telegram';

            // If Telegram failed, try SMS
            if (!sentViaTelegram) {
                let sentViaSMS = false;
                try {
                    await this.sendViaSMS(phoneNumber, otp);
                    sentViaSMS = true;
                    deliveryMethod = 'sms';
                    deliveryMessage = 'M√£ OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i qua SMS';
                    console.log(`‚úÖ OTP sent via SMS to ${phoneNumber}`);
                } catch (smsError) {
                    console.error(`‚ùå SMS failed, trying voice call for ${phoneNumber}`);
                    console.error(`SMS error: ${smsError.message}`);
                    
                    // Try voice call as final fallback
                    try {
                        await this.sendViaVoiceCall(phoneNumber, otp);
                        deliveryMethod = 'voice';
                        deliveryMessage = 'M√£ OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i qua cu·ªôc g·ªçi tho·∫°i';
                        console.log(`‚úÖ OTP sent via voice call to ${phoneNumber}`);
                    } catch (voiceError) {
                        console.error(`‚ùå All delivery methods failed for ${phoneNumber}`);
                        console.error(`Voice error: ${voiceError.message}`);
                        
                        // For development, still allow console log
                        deliveryMethod = 'console';
                        deliveryMessage = 'M√£ OTP ƒë∆∞·ª£c hi·ªÉn th·ªã tr√™n m√†n h√¨nh (Demo mode)';
                        console.log(`üîß Development mode: OTP ${otp} logged to console`);
                        
                        // Return OTP in response for demo
                        return {
                            success: true,
                            message: deliveryMessage,
                            method: deliveryMethod,
                            expiryTime: expiry,
                            otp: otp // Always show OTP when all methods fail
                        };
                    }
                }
            }

            return {
                success: true,
                message: deliveryMessage,
                method: deliveryMethod,
                expiryTime: expiry,
                // For development only - remove in production
                devOTP: process.env.NODE_ENV === 'development' ? otp : undefined
            };
        } catch (error) {
            console.error('‚ùå Error sending OTP:', error);
            throw error;
        }
    }

    async sendViaTelegram(phoneNumber, otp) {
        if (!this.telegramClientService) {
            throw new Error('Telegram service not available');
        }

        // Check if user exists and has active Telegram session
        const user = await this.dbManager.getUserByPhone(phoneNumber);
        if (!user) {
            throw new Error('User not found - will register on OTP verification');
        }

        if (!user.is_telegram_connected) {
            throw new Error('User not connected to Telegram');
        }

        if (!this.telegramClientService.isUserClientConnected(user.id)) {
            throw new Error('User Telegram client not active');
        }

        // Send OTP message via Telegram (to self)
        const message = `üîê M√£ x√°c th·ª±c Cown: *${otp}*\n‚è∞ C√≥ hi·ªáu l·ª±c trong 5 ph√∫t.\n\nüêÑ ƒê·ª´ng chia s·∫ª m√£ n√†y v·ªõi ai kh√°c!`;
        
        // Find "Saved Messages" chat (chat with self)
        const dialogs = await this.telegramClientService.getDialogsForUser(user.id);
        const savedMessages = dialogs.find(dialog => dialog.isUser && dialog.id === user.telegram_user_id);
        
        if (!savedMessages) {
            throw new Error('Cannot find Saved Messages chat');
        }

        await this.telegramClientService.sendMessageForUser(user.id, savedMessages.id, message, {
            parseMode: 'Markdown'
        });

        return true;
    }

    async sendViaVoiceCall(phoneNumber, otp) {
        console.log(`üìû Making voice call to ${phoneNumber} with OTP: ${otp}`);
        
        if (this.twilioClient && process.env.TWILIO_PHONE_NUMBER) {
            try {
                // Create TwiML for voice message
                const message = `Xin ch√†o! M√£ x√°c th·ª±c Cown c·ªßa b·∫°n l√†: ${otp.split('').join(', ')}. T√¥i nh·∫Øc l·∫°i, m√£ x√°c th·ª±c l√†: ${otp.split('').join(', ')}. C·∫£m ∆°n b·∫°n!`;
                
                const twiml = `
                    <?xml version="1.0" encoding="UTF-8"?>
                    <Response>
                        <Say voice="woman" language="vi-VN">${message}</Say>
                        <Pause length="2"/>
                        <Say voice="woman" language="vi-VN">${message}</Say>
                    </Response>
                `;
                
                const result = await this.twilioClient.calls.create({
                    twiml: twiml,
                    from: process.env.TWILIO_PHONE_NUMBER,
                    to: phoneNumber
                });
                
                console.log(`‚úÖ Voice call initiated successfully via Twilio. SID: ${result.sid}`);
                return true;
            } catch (error) {
                console.error(`‚ùå Twilio voice call failed: ${error.message}`);
                throw new Error(`Kh√¥ng th·ªÉ g·ªçi ƒëi·ªán: ${error.message}`);
            }
        } else {
            // Fallback for development
            console.log(`üîß Development mode: Voice call would be made to ${phoneNumber} with OTP: ${otp}`);
            
            // Always allow fallback in production for testing
            return true;
        }
    }

    async sendViaSMS(phoneNumber, otp) {
        console.log(`üì± Sending SMS to ${phoneNumber}: M√£ x√°c th·ª±c Cown: ${otp}. C√≥ hi·ªáu l·ª±c trong 5 ph√∫t.`);
        
        if (this.twilioClient && process.env.TWILIO_PHONE_NUMBER) {
            try {
                const message = `M√£ x√°c th·ª±c Cown: ${otp}. C√≥ hi·ªáu l·ª±c trong 5 ph√∫t. ƒê·ª´ng chia s·∫ª m√£ n√†y v·ªõi ai kh√°c!`;
                
                const result = await this.twilioClient.messages.create({
                    body: message,
                    from: process.env.TWILIO_PHONE_NUMBER,
                    to: phoneNumber
                });
                
                console.log(`‚úÖ SMS sent successfully via Twilio. SID: ${result.sid}`);
                return true;
            } catch (error) {
                console.error(`‚ùå Twilio SMS failed: ${error.message}`);
                console.error(`‚ùå Twilio error code: ${error.code || 'N/A'}`);
                console.error(`‚ùå Twilio error details: ${error.moreInfo || 'N/A'}`);
                throw new Error(`Kh√¥ng th·ªÉ g·ª≠i SMS: ${error.message}`);
            }
        } else {
            // Fallback for development or when Twilio is not configured
            console.log(`üîß Development mode: SMS would be sent to ${phoneNumber} with OTP: ${otp}`);
            
            // Always allow fallback in production for testing
            return true;
        }
    }

    async verifyOTP(phoneNumber, providedOTP) {
        try {
            console.log(`üîç Verifying OTP for ${phoneNumber}`);

            const storedData = this.otpStore.get(phoneNumber);
            if (!storedData) {
                throw new Error('Kh√¥ng t√¨m th·∫•y m√£ OTP. Vui l√≤ng y√™u c·∫ßu m√£ m·ªõi.');
            }

            // Check expiry
            if (Date.now() > storedData.expiry) {
                this.otpStore.delete(phoneNumber);
                throw new Error('M√£ OTP ƒë√£ h·∫øt h·∫°n. Vui l√≤ng y√™u c·∫ßu m√£ m·ªõi.');
            }

            // Check attempts
            if (storedData.attempts >= this.maxAttempts) {
                this.otpStore.delete(phoneNumber);
                throw new Error('ƒê√£ v∆∞·ª£t qu√° s·ªë l·∫ßn th·ª≠. Vui l√≤ng y√™u c·∫ßu m√£ m·ªõi.');
            }

            // Verify OTP
            if (storedData.otp !== providedOTP) {
                storedData.attempts++;
                throw new Error(`M√£ OTP kh√¥ng ƒë√∫ng. C√≤n l·∫°i ${this.maxAttempts - storedData.attempts} l·∫ßn th·ª≠.`);
            }

            // OTP verified successfully
            this.otpStore.delete(phoneNumber);
            console.log(`‚úÖ OTP verified successfully for ${phoneNumber}`);

            return {
                success: true,
                message: 'X√°c th·ª±c th√†nh c√¥ng'
            };
        } catch (error) {
            console.error('‚ùå Error verifying OTP:', error);
            throw error;
        }
    }

    cleanExpiredOTPs() {
        const now = Date.now();
        for (const [phoneNumber, data] of this.otpStore) {
            if (now > data.expiry) {
                this.otpStore.delete(phoneNumber);
                console.log(`üßπ Cleaned expired OTP for ${phoneNumber}`);
            }
        }
    }

    // For development/testing
    async sendSMS(phoneNumber, message) {
        // TODO: Implement real SMS service
        // Example with Twilio:
        /*
        const twilio = require('twilio');
        const client = twilio(process.env.TWILIO_SID, process.env.TWILIO_TOKEN);
        
        await client.messages.create({
            body: message,
            from: process.env.TWILIO_PHONE,
            to: phoneNumber
        });
        */
        
        console.log(`üì≤ SMS to ${phoneNumber}: ${message}`);
    }

    getOTPStatus(phoneNumber) {
        const data = this.otpStore.get(phoneNumber);
        if (!data) return null;

        return {
            hasOTP: true,
            expiresAt: data.expiry,
            attemptsUsed: data.attempts,
            attemptsRemaining: this.maxAttempts - data.attempts
        };
    }

    /**
     * Health check method
     */
    async healthCheck() {
        try {
            // Test Twilio connection if configured
            if (this.isConfigured) {
                // Could test Twilio here if needed
                return {
                    service: 'OTPService',
                    status: 'healthy',
                    provider: 'twilio',
                    activeOTPs: this.otpStore.size,
                    timestamp: new Date().toISOString()
                };
            } else {
                return {
                    service: 'OTPService',
                    status: 'healthy',
                    provider: 'console',
                    activeOTPs: this.otpStore.size,
                    timestamp: new Date().toISOString()
                };
            }
        } catch (error) {
            return {
                service: 'OTPService',
                status: 'unhealthy',
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }
}

module.exports = OTPService;
